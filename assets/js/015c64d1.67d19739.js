"use strict";(self.webpackChunkfiber_website=self.webpackChunkfiber_website||[]).push([[9225],{3905:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>d});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),b=c(o),d=r,m=b["".concat(l,".").concat(d)]||b[d]||p[d]||a;return o?n.createElement(m,i(i({ref:t},u),{},{components:o})):n.createElement(m,i({ref:t},u))}));function d(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=o[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}b.displayName="MDXCreateElement"},5162:(e,t,o)=>{o.d(t,{Z:()=>i});var n=o(7294),r=o(6010);const a="tabItem_Ymn6";function i(e){let{children:t,hidden:o,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(a,i),hidden:o},t)}},5488:(e,t,o)=>{o.d(t,{Z:()=>d});var n=o(7462),r=o(7294),a=o(6010),i=o(2389),s=o(7392),l=o(7094),c=o(2466);const u="tabList__CuJ",p="tabItem_LNqP";function b(e){var t;const{lazy:o,block:i,defaultValue:b,values:d,groupId:m,className:h}=e,f=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=d??f.map((e=>{let{props:{value:t,label:o,attributes:n}}=e;return{value:t,label:o,attributes:n}})),k=(0,s.l)(g,((e,t)=>e.value===t.value));if(k.length>0)throw new Error(`Docusaurus error: Duplicate values "${k.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===b?b:b??(null==(t=f.find((e=>e.props.default)))?void 0:t.props.value)??f[0].props.value;if(null!==v&&!g.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:w}=(0,l.U)(),[T,N]=(0,r.useState)(v),E=[],{blockElementScrollPositionUntilNextRender:O}=(0,c.o5)();if(null!=m){const e=y[m];null!=e&&e!==T&&g.some((t=>t.value===e))&&N(e)}const x=e=>{const t=e.currentTarget,o=E.indexOf(t),n=g[o].value;n!==T&&(O(t),N(n),null!=m&&w(m,String(n)))},P=e=>{var t;let o=null;switch(e.key){case"ArrowRight":{const t=E.indexOf(e.currentTarget)+1;o=E[t]??E[0];break}case"ArrowLeft":{const t=E.indexOf(e.currentTarget)-1;o=E[t]??E[E.length-1];break}}null==(t=o)||t.focus()};return r.createElement("div",{className:(0,a.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":i},h)},g.map((e=>{let{value:t,label:o,attributes:i}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>E.push(e),onKeyDown:P,onFocus:x,onClick:x},i,{className:(0,a.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":T===t})}),o??t)}))),o?(0,r.cloneElement)(f.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function d(e){const t=(0,i.Z)();return r.createElement(b,(0,n.Z)({key:String(t)},e))}},1636:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var n=o(7462),r=(o(7294),o(3905)),a=o(5488),i=o(5162);const s={sidebar_position:4,title:"FiberBoost"},l=void 0,c={unversionedId:"usage/fiber-boost",id:"usage/fiber-boost",title:"FiberBoost",description:'FiberBoost is a service that broadcasts ("boosts") blocks through the Fiber Network for faster global propagation, resulting in a reduced probability of missed slots due to proposer boost & honest reorgs. FiberBoost provides multiple interfaces to boost blocks:',source:"@site/docs/usage/fiber-boost.mdx",sourceDirName:"usage",slug:"/usage/fiber-boost",permalink:"/docs/usage/fiber-boost",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usage/fiber-boost.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"FiberBoost"},sidebar:"tutorialSidebar",previous:{title:"Broadcasting Transactions",permalink:"/docs/usage/broadcasting-txs"},next:{title:"FiberGuard",permalink:"/docs/usage/fiber-guard"}},u={},p=[{value:"gRPC API",id:"grpc-api",level:2},{value:"MEV-Boost",id:"mev-boost",level:2},{value:"How it works",id:"how-it-works",level:3},{value:"Running it",id:"running-it",level:3},{value:"Direct Peering",id:"direct-peering",level:2}],b={toc:p};function d(e){let{components:t,...s}=e;return(0,r.kt)("wrapper",(0,n.Z)({},b,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'FiberBoost is a service that broadcasts ("boosts") blocks through the Fiber Network for faster global propagation, resulting in a reduced probability of missed slots due to ',(0,r.kt)("a",{parentName:"p",href:"https://www.paradigm.xyz/2023/04/mev-boost-ethereum-consensus#proposer-boost--honest-reorgs"},"proposer boost & honest reorgs"),". FiberBoost provides multiple interfaces to boost blocks:"),(0,r.kt)("h2",{id:"grpc-api"},"gRPC API"),(0,r.kt)("p",null,"The most straightforward and performant way to publish a block to Fiber is through the gRPC API. The ",(0,r.kt)("inlineCode",{parentName:"p"},"PublishBlock")," endpoint is a bi-directional gRPC stream that accepts ",(0,r.kt)("strong",{parentName:"p"},"SSZ encoded, signed beacon blocks"),". The blocks can optionally be compressed with gzip."),(0,r.kt)("p",null,"Both ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chainbound/fiber-go/releases/tag/v1.8.0"},(0,r.kt)("inlineCode",{parentName:"a"},"fiber-go >= v1.8.0"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chainbound/fiber-rs/releases/tag/v0.5.1"},(0,r.kt)("inlineCode",{parentName:"a"},"fiber-rs >= v0.5.1"))," provide an implementation of this method with gzip compression:"),(0,r.kt)(a.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"go",label:"Golang",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "fmt"\n    "log"\n    "time"\n\n    fiber "github.com/chainbound/fiber-go"\n)\n\n\nfunc main() {\n    // Connection process omitted\n    ...\n\n    // SSZ encoded, signed beacon block\n    beaconBlock := []byte{...}\n\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n    defer cancel()\n\n    // Returns the slot, root, and timestamp of the block, or a potential error\n    slot, root, timestamp, err := client.SubmitBlock(ctx, beaconBlock)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println("Submitted block", slot, root, timestamp)\n}\n'))),(0,r.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use bytes::Bytes;\nuse fiber::{Client, api::BlockSubmissionResponse};\n\n#[tokio::main]\nasync fn main() {\n    // Connection process omitted\n    // ....\n\n    // SSZ encoded, signed beacon block\n    let beacon_block = vec![...];\n\n    let result: BlockSubmissionResponse = client.publish_block(beacon_block).await.unwrap();\n\n    println!("Submitted block: {} {:#x} {}", block.slot, block.root, block.timestamp);\n}\n')))),(0,r.kt)("h2",{id:"mev-boost"},"MEV-Boost"),(0,r.kt)("p",null,"Chainbound maintains an open-source, modified version of the ",(0,r.kt)("a",{parentName:"p",href:"https://boost.flashbots.net"},"MEV-Boost")," validator sidecar at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chainbound/mev-boost"},"this repository"),". The fork has a very minimal diff with the upstream Flashbots repository and follows the same release schedule. Track the diff ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chainbound/mev-boost/pull/1"},"here"),"."),(0,r.kt)("h3",{id:"how-it-works"},"How it works"),(0,r.kt)("p",null,"The following interaction diagram depicts the block proposal process using the modified MEV-Boost:\n",(0,r.kt)("img",{src:o(6433).Z,width:"2600",height:"1656"}),"\n",(0,r.kt)("strong",{parentName:"p"},"The main difference with normal MEV-Boost is that when it receives a ",(0,r.kt)("inlineCode",{parentName:"strong"},"Payload")," from the relay, it will reconstruct the full signed beacon block, SSZ encode it and publish it to Fiber.")),(0,r.kt)("p",null,"If you're a validator running MEV-Boost, this is the easiest way to start using FiberBoost."),(0,r.kt)("h3",{id:"running-it"},"Running it"),(0,r.kt)("p",null,"Coming soon!"),(0,r.kt)("h2",{id:"direct-peering"},"Direct Peering"),(0,r.kt)("p",null,"Just like with ",(0,r.kt)("a",{parentName:"p",href:"/docs/usage/fiber-guard"},"FiberGuard"),", we offer a direct peering connection on the consensus layer for boosting blocks. This means that all blocks we receive on said connection will be boosted on our network."),(0,r.kt)("p",null,"The requirements and setup procedure are the same as with FiberGuard, you can read them ",(0,r.kt)("a",{parentName:"p",href:"/docs/usage/fiber-guard#requirements"},"here"),"."))}d.isMDXComponent=!0},6433:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/fiber-boost-18772d21b482b01361b4475cb44337bd.png"}}]);