"use strict";(self.webpackChunkfiber_website=self.webpackChunkfiber_website||[]).push([[6387],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),m=r,u=h["".concat(l,".").concat(m)]||h[m]||d[m]||o;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={slug:"reth-p2p",title:"Diving into the Reth p2p stack",authors:["jonas"],tags:["ethereum","devp2p","reth","rust"]},i=void 0,s={permalink:"/blog/reth-p2p",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-02-17-reth-p2p/index.md",source:"@site/blog/2023-02-17-reth-p2p/index.md",title:"Diving into the Reth p2p stack",description:"Recently, the engineering team at Paradigm unveiled a new open-source execution client",date:"2023-02-17T00:00:00.000Z",formattedDate:"February 17, 2023",tags:[{label:"ethereum",permalink:"/blog/tags/ethereum"},{label:"devp2p",permalink:"/blog/tags/devp-2-p"},{label:"reth",permalink:"/blog/tags/reth"},{label:"rust",permalink:"/blog/tags/rust"}],readingTime:11.39,hasTruncateMarker:!0,authors:[{name:"Jonas Bostoen",title:"Chainbound CTO",url:"https://github.com/jonasbostoen",imageURL:"https://github.com/jonasbostoen.png",key:"jonas"}],frontMatter:{slug:"reth-p2p",title:"Diving into the Reth p2p stack",authors:["jonas"],tags:["ethereum","devp2p","reth","rust"]},prevItem:{title:"Fiber vs. Bloxroute: The Standoff",permalink:"/blog/fiber-vs-bloxroute"},nextItem:{title:"Identifying hotspots on the Ethereum p2p network",permalink:"/blog/ethereum-hotspots"}},l={authorsImageUrls:[void 0]},p=[{value:"Showcase",id:"showcase",level:2},{value:"Creating our own message handlers",id:"creating-our-own-message-handlers",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Peer lifecycle",id:"peer-lifecycle",level:3},{value:"More examples",id:"more-examples",level:2},{value:"Other ideas",id:"other-ideas",level:3},{value:"Further reading",id:"further-reading",level:2},{value:"Footnotes",id:"footnotes",level:2}],c={toc:p};function d(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recently, the engineering team at Paradigm ",(0,r.kt)("a",{parentName:"p",href:"https://www.paradigm.xyz/2022/12/reth"},"unveiled")," a new open-source execution client\ncalled ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://github.com/paradigmxyz/reth"},"Reth")),". In short, reth aims to be an execution client to serve a large\nuser base, including ",(0,r.kt)("strong",{parentName:"p"},"power users")," like MEV searchers, RPC node operators, block builders, and more. It will do so by making reth highly\nperformant, but also very configurable, so that users can tweak and tune the settings to find the optimal setup\nfor their use case. No other execution client is doing this, so this is big positive for the space."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(7387).Z,width:"1404",height:"1004"})),(0,r.kt)("p",null,"Aside from this and the fact that ",(0,r.kt)("a",{parentName:"p",href:"https://clientdiversity.org/#distribution"},"client diversity")," is crucial,\nreth aims to accomodate developers as well.\n",(0,r.kt)("strong",{parentName:"p"},"Every part of the reth stack will be modular enough to use as a standalone component in your stack"),".\nIn their article, Paradigm mentions the blazing-fast database bindings that indexing companies could use,\nand that their EVM can be leveraged by ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-4337"},"ERC4337")," bundlers to run fast simulations.\nIn this article, we\u2019ll talk about the architecture and usage of the networking stack, which plays an important role in ",(0,r.kt)("a",{parentName:"p",href:"https://fiber.chainbound.io"},"Fiber Network"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"\ud83d\udca1 When I\u2019m referencing reth code, you will find a Github permalink in the footnotes. "),(0,r.kt)("p",{parentName:"admonition"},"All the example code (including dependencies and versions) can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/jonasbostoen/reth-p2p-showcase"},"https://github.com/jonasbostoen/reth-p2p-showcase"),".")),(0,r.kt)("h2",{id:"showcase"},"Showcase"),(0,r.kt)("p",null,"We don\u2019t just want to tell you about how great it is, we want to show you. Below is a Rust code snippet of how you can spin up a minimal ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p"},"devp2p")," node and listen to network events:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/simple.rs"',title:'"examples/simple.rs"'},'use secp256k1::{rand, SecretKey};\nuse std::sync::Arc;\nuse tokio_stream::StreamExt;\n\nuse reth_network::{NetworkConfig, NetworkManager};\nuse reth_provider::test_utils::NoopProvider;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Generate a random ECDSA private key.\n    let secret = SecretKey::new(&mut rand::thread_rng());\n\n    // Create the network builder with the secret key, which allows you to configure the network.\n    // The defaults will do for now, but we\'ll disable DNS discovery\n        // and specify the bootnodes discv4 should use for discovering peers.\n        let builder = NetworkConfig::<NoopProvider>::builder(secret)\n        .disable_dns_discovery()\n        .boot_nodes(mainnet_nodes());\n\n    // Build the config. The configuration needs a client to interact with the chain (to respond to block header\n    // and block bodies requests), but for now we\'ll just use a no-op client.\n    let config = builder.build(Arc::new(NoopProvider::default()));\n    let network = NetworkManager::new(config).await?;\n\n    // Get a handle to the network manager\n    let network_handle = network.handle().clone();\n    // Subscribe to network events\n    let mut network_events = network_handle.event_listener();\n    println!("Starting network manager...");\n    // Spawn the network manager task. This will start the network manager\n    // and all the subcomponents necessary for the devp2p stack.\n    tokio::spawn(network);\n\n    while let Some(net_event) = network_events.next().await {\n        println!("Received network event: {:?}", net_event);\n    }\n\n    Ok(())\n}\n')),(0,r.kt)("p",null,"All of the complexities of discovery, peer and session management, and message handling are nicely bundled inside of the ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkManager"),". We'll cover\nthat in more details below, but for now, you can just run it with"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cargo r --example simple\n")),(0,r.kt)("p",null,"After a while you should start to see network events like ",(0,r.kt)("inlineCode",{parentName:"p"},"PeerAdded"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"PeerRemoved"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SessionEstablished")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SessionClosed"),(0,r.kt)("sup",{parentName:"p",id:"fnref-1-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1-031754",className:"footnote-ref"},"1")),":"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(9441).Z,width:"2630",height:"846"})),(0,r.kt)("p",null,"Note that this is a very minimal example and you won\u2019t be able to maintain any peering connections, because for that, we would need to respond to ",(0,r.kt)("inlineCode",{parentName:"p"},"eth")," protocol\nrequests like ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/caps/eth.md#getblockheaders-0x03"},(0,r.kt)("inlineCode",{parentName:"a"},"GetBlockHeaders"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/caps/eth.md#getblockbodies-0x05"},(0,r.kt)("inlineCode",{parentName:"a"},"GetBlockBodies")),",\nwhich we can only do if we provide a valid chain provider (instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"NoopProvider"),")."),(0,r.kt)("p",null,"This doesn\u2019t give us a lot of information though. Reth uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"tracing")," library for logging events,\nwhich we can activate with the ",(0,r.kt)("inlineCode",{parentName:"p"},"RUST_LOG")," environment variable."),(0,r.kt)("p",null,"If we run our binary with ",(0,r.kt)("inlineCode",{parentName:"p"},"RUST_LOG")," set to ",(0,r.kt)("inlineCode",{parentName:"p"},"trace"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"debug")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"info"),", we can see a lot more of what\u2019s happening under the hood:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"RUST_LOG=debug cargo r --example simple\n")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(7727).Z,width:"2744",height:"814"})),(0,r.kt)("p",null,"If you want to zoom in on certain trace targets you can do so by tuning the ",(0,r.kt)("inlineCode",{parentName:"p"},"RUST_LOG")," variable, for example,\nsetting it to ",(0,r.kt)("inlineCode",{parentName:"p"},"RUST_LOG=discv4=trace,net=info"),"."),(0,r.kt)("h3",{id:"creating-our-own-message-handlers"},"Creating our own message handlers"),(0,r.kt)("p",null,"We were able to run a minimally functional devp2p node in about 20 lines of code, which is impressive. But let\u2019s take a look at what else the modular design allows us to do.\nIn this following example, we\u2019ll set the basis for providing custom handlers for ",(0,r.kt)("inlineCode",{parentName:"p"},"eth")," protocol messages like ",(0,r.kt)("inlineCode",{parentName:"p"},"GetBlockHeaders")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GetBlockBodies"),",\nbut also for the transaction exchange messages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PooledTransactionHashes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Transactions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PooledTransactions"))),(0,r.kt)("p",null,"This could be useful if you want to route ",(0,r.kt)("inlineCode",{parentName:"p"},"eth")," sync requests to another location (say you\u2019re running this as a sentry and want to relay requests to another node that keeps the actual blockchain state).\nOr you want to build your own transaction pool logic so you need access to all the transaction messages you\u2019re receiving from the network. We can do this by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"set_eth_request_handler")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"set_transactions")," methods on our ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkManager")," like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/custom_handlers.rs"',title:'"examples/custom_handlers.rs"'},'use reth_p2p::init_tracing;\nuse secp256k1::{rand, SecretKey};\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tokio_stream::StreamExt;\n\nuse reth_discv4::bootnodes::mainnet_nodes;\nuse reth_network::{NetworkConfig, NetworkManager, PeersConfig};\nuse reth_provider::test_utils::NoopProvider;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    init_tracing();\n    // Generate a random ECDSA private key.\n    let secret = SecretKey::new(&mut rand::thread_rng());\n\n    // // Create a peer configuration with max 10 outbound and 10 inbound peers.\n    let peer_config = PeersConfig::default()\n        .with_max_outbound(10)\n        .with_max_inbound(10);\n\n    // Add the peer configuration here.\n    let builder = NetworkConfig::<NoopProvider>::builder(secret)\n        .disable_dns_discovery()\n        .boot_nodes(mainnet_nodes())\n        .peer_config(peer_config);\n\n    // Build the config. The configuration needs a client to interact with the chain (to respond to block header\n    // and block bodies requests), but for now we\'ll just use a no-op client.\n    let config = builder.build(Arc::new(NoopProvider::default()));\n    let mut network = NetworkManager::new(config).await?;\n\n    // Create the channels for receiving eth messages\n    let (eth_tx, mut eth_rx) = mpsc::unbounded_channel();\n    let (transaction_tx, mut transaction_rx) = mpsc::unbounded_channel();\n\n    network.set_eth_request_handler(eth_tx);\n    network.set_transactions(transaction_tx);\n\n    let network_handle = network.handle().clone();\n    let mut network_events = network_handle.event_listener();\n    println!("Starting network manager...");\n    tokio::spawn(network);\n\n    loop {\n        tokio::select! {\n            Some(tx_event) = transaction_rx.recv() => {\n                println!("New transaction event: {:?}", tx_event);\n            }\n\n            Some(eth_req) = eth_rx.recv() => {\n                println!("New eth protocol request: {:?}", eth_req);\n            }\n\n            Some(net_event) = network_events.next() => {\n                println!("New network event: {:?}", net_event);\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",null,"When you run the ",(0,r.kt)("inlineCode",{parentName:"p"},"custom_handlers")," example now, you will occasionally see these messages printed out. Note that in this example,\nI\u2019ve also used a custom peer configuration that specifies the maximum number of outbound and inbound peers.\nNow that we have a very slim idea of what we can do with ",(0,r.kt)("inlineCode",{parentName:"p"},"reth-network"),", let\u2019s have a closer look at the architecture before looking at some more options."),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"At a high level, the p2p stack is implemented as a hierarchy of ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Finite-state_machine"},"state machines")," where parents pass events down to their children, and children bubble up events to their parents.\n",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkManager"),(0,r.kt)("sup",{parentName:"p",id:"fnref-2-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2-031754",className:"footnote-ref"},"2"))," is the entry point of this whole hierarchy, and it is implemented as an endless ",(0,r.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/async-book/02_execution/02_future.html"},"future"),".\nWhen we spawn the manager with ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio::spawn(network)"),", we let the tokio runtime drive the state of the manager forward.\nThe runtime continually calls ",(0,r.kt)("inlineCode",{parentName:"p"},"poll"),(0,r.kt)("sup",{parentName:"p",id:"fnref-3-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-3-031754",className:"footnote-ref"},"3")),", which in turn polls all the underlying components, all the way down the hierarchy.\nThis mechanism is how the events bubble up and work is performed",(0,r.kt)("sup",{parentName:"p",id:"fnref-4-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-4-031754",className:"footnote-ref"},"4")),". The architecture in a diagram looks like this:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(4677).Z,width:"2435",height:"2416"})),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Discv5")," is greyed out because it\u2019s still in the works. One thing we\u2019ve seen in the code but haven\u2019t talked about yet is the ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkHandle"),", which we got with ",(0,r.kt)("inlineCode",{parentName:"p"},"network.handle().clone()"),". This is a thread-safe, clonable handle that can be used to communicate with the network manager and all of the other components it manages.\nIf you look at the whole reth codebase, you\u2019ll see that this handle is shared between all the different subsystems that need access to the network, like the state syncer.\nThis pattern is somewhat similar to the ",(0,r.kt)("a",{parentName:"p",href:"https://ryhl.io/blog/actors-with-tokio/"},"actor pattern"),"."),(0,r.kt)("p",null,"For us, it also has a very interesting interface. We can use it to broadcast transactions or transaction announcements, add and remove (trusted) peers, change peer reputation, and so on.\nTake a look at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/24bc633bbda05de0772c66b851af83c63a028144/crates/net/network/src/network.rs"},"this file")," for more information.\nWe won\u2019t cover what each component does in too much depth, since that\u2019s already being done in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/tree/main/docs"},"reth developer docs"),"."),(0,r.kt)("h3",{id:"peer-lifecycle"},"Peer lifecycle"),(0,r.kt)("p",null,"Let\u2019s take a look at the lifecycle of a peer in the networking stack, because this will involve every component we\u2019ve outlined above.\nSpecifically, we\u2019ll look at outbound connections, because it's a more complex process."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Discovery"),(0,r.kt)("sup",{parentName:"p",id:"fnref-5-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-5-031754",className:"footnote-ref"},"5"))," is the service responsible for discovering peers. It currently envelops 2 subsystems: ",(0,r.kt)("inlineCode",{parentName:"p"},"Discv4"),(0,r.kt)("sup",{parentName:"p",id:"fnref-6-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-6-031754",className:"footnote-ref"},"6"))," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DnsDiscovery"),(0,r.kt)("sup",{parentName:"p",id:"fnref-7-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-7-031754",className:"footnote-ref"},"7")),", with ",(0,r.kt)("inlineCode",{parentName:"p"},"Discv5")," in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/issues/1383"},"pipeline"),".\nIf you want to dive deeper into how these mechanisms work, see the links in the footnotes. Discovering a peer is the first step in the peer lifecycle.\nIn short, the discovery service queries other nodes over UDP for their neighbors, starting with the pre-defined bootstrap nodes. The nodes in a response message\nare queried in turn, and so on, so that our node gradually builds up a picture of the network. Every node undergoes a couple of checks, and if passed, is considered a newly discovered node."),(0,r.kt)("p",null,"Once a new node is discovered, the discovery service will bubble up an event with the information of the peer to the ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkState"),(0,r.kt)("sup",{parentName:"p",id:"fnref-8-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-8-031754",className:"footnote-ref"},"8")),", which in turn notifies the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swarm"),(0,r.kt)("sup",{parentName:"p",id:"fnref-9-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-9-031754",className:"footnote-ref"},"9")),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"Swarm")," in then does an ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-2124"},"EIP-2124")," fork ID check. If this check passes, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swarm")," adds the peer to the ",(0,r.kt)("inlineCode",{parentName:"p"},"PeerManager"),", where it will sit as a candidate to be dialed",(0,r.kt)("sup",{parentName:"p",id:"fnref-10-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-10-031754",className:"footnote-ref"},"10")),"."),(0,r.kt)("p",null,"Depending on wether there are any outbound peer slots available, the peer will be bubbled up as a dial candidate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swarm")," again.\nThis time, it will pass it down to ",(0,r.kt)("inlineCode",{parentName:"p"},"SessionManager")," to start an outbound session with",(0,r.kt)("sup",{parentName:"p",id:"fnref-11-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-11-031754",className:"footnote-ref"},"11")),".\nSpecifically, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swarm")," calls ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/session/mod.rs#L215"},(0,r.kt)("inlineCode",{parentName:"a"},"dial_outbound")),",\nwhich will try to establish a session with the peer by running the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md"},"RLPx")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/caps/eth.md"},"eth")," protocol handshakes.\nOnce these handshakes pass, the peer will move from the pending to the active state,\nand a new ",(0,r.kt)("inlineCode",{parentName:"p"},"ActiveSession")," will be created, which wraps the underlying RLPx and ",(0,r.kt)("inlineCode",{parentName:"p"},"eth")," connection with said peer",(0,r.kt)("sup",{parentName:"p",id:"fnref-12-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-12-031754",className:"footnote-ref"},"12")),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"SessionManager")," keeps track of all these sessions, and notifies its parents about any messages, like transactions or block header requests."),(0,r.kt)("p",null,"We\u2019ve skipped over some parts of the work involved, but hopefully you now have some idea about how these components interact, and how there is a clean ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Separation_of_concerns"},"seperation of concerns"),"."),(0,r.kt)("h2",{id:"more-examples"},"More examples"),(0,r.kt)("p",null,"What if you want to bypass the default discovery services and only add peers that you\u2019ve evaluated somehow? This evaluation function could be anything, like"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ping the remote endpoint and only go ahead if RTT is below a certain threshold (contrived example, don't do this in prod)"),(0,r.kt)("li",{parentName:"ul"},"Check if the IP address belongs to a certain cloud provider or is in a certain country / region"),(0,r.kt)("li",{parentName:"ul"},"\u2026")),(0,r.kt)("p",null,"For this example we\u2019ll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Discv4")," service, but you could also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Discovery")," service, which does both discv4 and DNS discovery.\nFirst we\u2019ll disable the default discovery services, and then spawn our own discv4 service.\nWe listen to the discovery events, and when a new node is added, we run the evaluation function, only proceeding with adding the peer\nif it evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/custom_disc.rs"',title:'"examples/custom_disc.rs"'},'use reth_p2p::init_tracing;\nuse secp256k1::{rand, SecretKey};\nuse std::{net::SocketAddr, str::FromStr, sync::Arc, time::Duration};\nuse tokio_stream::StreamExt;\n\nuse reth_discv4::{\n    bootnodes::mainnet_nodes, DiscoveryUpdate, Discv4, Discv4ConfigBuilder, NodeRecord,\n};\nuse reth_network::{NetworkConfig, NetworkManager};\nuse reth_network_api::{PeerKind, Peers};\nuse reth_provider::test_utils::NoopProvider;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    init_tracing();\n    // Generate a random ECDSA private key.\n    let secret = SecretKey::new(&mut rand::thread_rng());\n\n    // Disable the default discovery services.\n    let builder = NetworkConfig::<NoopProvider>::builder(secret)\n        .disable_dns_discovery()\n        .disable_discv4_discovery()\n        .boot_nodes(mainnet_nodes());\n\n    // Build the config. The configuration needs a client to interact with the chain (to respond to block header\n    // and block bodies requests), but for now we\'ll just use a no-op client.\n    let config = builder.build(Arc::new(NoopProvider::default()));\n    let network = NetworkManager::new(config).await?;\n\n    let peer_id = *network.peer_id();\n\n    // Get a handle to the network manager\n    let network_handle = network.handle().clone();\n    println!("Starting network manager...");\n    // Spawn the network manager task. This will start the network manager\n    // and all the subcomponents necessary for the devp2p stack.\n    tokio::spawn(network);\n\n    // Build local node record\n    let disc_addr = SocketAddr::from_str("0.0.0.0:30303").unwrap();\n    let local_enr = NodeRecord {\n        id: peer_id,\n        address: disc_addr.ip(),\n        tcp_port: disc_addr.port(),\n        udp_port: disc_addr.port(),\n    };\n\n    // Create the discv4 config\n    let discv4_config = Discv4ConfigBuilder::default()\n        // Decrease lookup interval to 5 seconds (from 20 sec default)\n        .lookup_interval(Duration::from_secs(5))\n        // Decrease ban duration to 30 minutes\n        .ban_duration(Some(Duration::from_secs(30 * 60)))\n        .add_boot_nodes(mainnet_nodes())\n        .build();\n\n    let (_discv4, mut service) = Discv4::bind(disc_addr, local_enr, secret, discv4_config).await?;\n    let mut disc_updates = service.update_stream();\n\n    // Spawn the discv4 service\n    let _handle = service.spawn();\n\n    while let Some(disc_event) = disc_updates.next().await {\n        match disc_event {\n            DiscoveryUpdate::Added(enr) | DiscoveryUpdate::DiscoveredAtCapacity(enr) => {\n                println!("Discovered new node: {:?}", enr);\n                // Evaluate if we want to connect to peer\n                if custom_peer_eval_func(&enr) {\n                    network_handle.add_peer(enr.id, enr.tcp_addr());\n                }\n            }\n            DiscoveryUpdate::Removed(id) => {\n                network_handle.remove_peer(id, PeerKind::Basic);\n            }\n            _ => {}\n        }\n    }\n\n    Ok(())\n}\n\n// This function could be used to add some custom peer evaluation logic,\n// like a ping below n milliseconds.\nfn custom_peer_eval_func(_enr: &NodeRecord) -> bool {\n    true\n}\n')),(0,r.kt)("p",null,"We\u2019ve also tweaked some settings here like the default ban duration and the lookup interval, which will have an effect on how fast you\u2019ll discover new nodes. Note that you\u2019ll want to run the peer evaluation function asynchronously if you\u2019re doing any network I/O like pings, to not block the event handling loop."),(0,r.kt)("h3",{id:"other-ideas"},"Other ideas"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use the ",(0,r.kt)("inlineCode",{parentName:"li"},"DiscoveryService")," to build a network crawler."),(0,r.kt)("li",{parentName:"ul"},"You can change the reputation of the peers you\u2019re connected to through the ",(0,r.kt)("inlineCode",{parentName:"li"},"NetworkHandle::reputation_change"),(0,r.kt)("sup",{parentName:"li",id:"fnref-13-031754"},(0,r.kt)("a",{parentName:"sup",href:"#fn-13-031754",className:"footnote-ref"},"13")),".\nThere are some default reputation penalties that reth implements on bad messages, disconnections, etc.,\nbut you can apply your own with ",(0,r.kt)("inlineCode",{parentName:"li"},"ReputationChangeKind::Other"),". This could allow you to build a peer set that meets certain requirements.")),(0,r.kt)("p",null,"Thanks for reading and feel free to contact me on Twitter ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/mempirate"},"@mempirate")," if you have any questions!"),(0,r.kt)("h2",{id:"further-reading"},"Further reading"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/paradigmxyz/reth/tree/main/docs"},"Reth developer docs")),(0,r.kt)("li",{parentName:"ul"},"The code documentation (run ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo doc --open")," in the repository)")),(0,r.kt)("h2",{id:"footnotes"},"Footnotes"),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/c5bc272057b473337191de50e7f86d07cf93c5a1/crates/net/network/src/manager.rs#L771"},"https://github.com/paradigmxyz/reth/blob/c5bc272057b473337191de50e7f86d07cf93c5a1/crates/net/network/src/manager.rs#L771"),(0,r.kt)("a",{parentName:"p",href:"#fnref-1-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-2-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/c5bc272057b473337191de50e7f86d07cf93c5a1/crates/net/network/src/manager.rs#L86"},"https://github.com/paradigmxyz/reth/blob/c5bc272057b473337191de50e7f86d07cf93c5a1/crates/net/network/src/manager.rs#L86"),(0,r.kt)("a",{parentName:"p",href:"#fnref-2-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-3-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/24bc633bbda05de0772c66b851af83c63a028144/crates/net/network/src/manager.rs#L466"},"https://github.com/paradigmxyz/reth/blob/"),(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/c5bc272057b473337191de50e7f86d07cf93c5a1/crates/net/network/src/manager.rs#L86"},"c5bc272057b473337191de50e7f86d07cf93c5a1"),(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/24bc633bbda05de0772c66b851af83c63a028144/crates/net/network/src/manager.rs#L466"},"/crates/net/network/src/manager.rs#L466"),(0,r.kt)("a",{parentName:"p",href:"#fnref-3-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-4-031754"},(0,r.kt)("p",{parentName:"li"},"This is similar to how rust-libp2p does it: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/libp2p/rust-libp2p/blob/master/docs/coding-guidelines.md"},"https://github.com/libp2p/rust-libp2p/blob/master/docs/coding-guidelines.md"),(0,r.kt)("a",{parentName:"p",href:"#fnref-4-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-5-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/6005ecb89a42b34facdaa020471347b47b043526/crates/net/network/src/discovery.rs#L23"},"https://github.com/paradigmxyz/reth/blob/6005ecb89a42b34facdaa020471347b47b043526/crates/net/network/src/discovery.rs#L23"),(0,r.kt)("a",{parentName:"p",href:"#fnref-5-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-6-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/6005ecb89a42b34facdaa020471347b47b043526/crates/net/discv4/src/lib.rs#L119"},"https://github.com/paradigmxyz/reth/blob/6005ecb89a42b34facdaa020471347b47b043526/crates/net/discv4/src/lib.rs#L119")),(0,r.kt)("p",{parentName:"li"},"  Spec: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/discv4.md"},"https://github.com/ethereum/devp2p/blob/master/discv4.md"),(0,r.kt)("a",{parentName:"p",href:"#fnref-6-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-7-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/dns/src/lib.rs#L86"},"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/dns/src/lib.rs#L86")),(0,r.kt)("p",{parentName:"li"},"  Spec: ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"https://eips.ethereum.org/EIPS/eip-1459"),(0,r.kt)("a",{parentName:"p",href:"#fnref-7-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-8-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/state.rs#L45"},"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/state.rs#L45"),(0,r.kt)("a",{parentName:"p",href:"#fnref-8-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-9-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/swarm.rs#L65"},"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/swarm.rs#L65"),(0,r.kt)("a",{parentName:"p",href:"#fnref-9-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-10-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/peers/manager.rs#L73"},"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/peers/manager.rs#L73"),(0,r.kt)("a",{parentName:"p",href:"#fnref-10-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-11-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/session/mod.rs#L52"},"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/session/mod.rs#L52"),(0,r.kt)("a",{parentName:"p",href:"#fnref-11-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-12-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/session/mod.rs#L370"},"https://github.com/paradigmxyz/reth/blob/f9de425ad895279c24a72977ffd0c6973afaf90e/crates/net/network/src/session/mod.rs#L370"),(0,r.kt)("a",{parentName:"p",href:"#fnref-12-031754",className:"footnote-backref"},"\u21a9"))),(0,r.kt)("li",{parentName:"ol",id:"fn-13-031754"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://github.dev/paradigmxyz/reth/blob/7c9b212b4a60838ce35c3db272788bd05d2eeec0/crates/net/network/src/network.rs#L215"},"https://github.dev/paradigmxyz/reth/blob/7c9b212b4a60838ce35c3db272788bd05d2eeec0/crates/net/network/src/network.rs#L215"),(0,r.kt)("a",{parentName:"p",href:"#fnref-13-031754",className:"footnote-backref"},"\u21a9"))))))}d.isMDXComponent=!0},7387:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/client-diversity-f113264a0139c916d9b66f9573e3e2d7.png"},4677:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/reth-network-architecture-71adc3ac8ed07b04bee8277d1f271388.png"},9441:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/screenshot-1-4fb89146d1e502ee4f13e017c6a6310d.png"},7727:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/screenshot-2-e13b190de472f8a9f24191b1f711c456.png"}}]);