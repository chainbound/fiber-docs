"use strict";(self.webpackChunkfiber_website=self.webpackChunkfiber_website||[]).push([[199],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},b=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),b=c(t),m=r,d=b["".concat(l,".").concat(m)]||b[m]||p[m]||o;return t?a.createElement(d,i(i({ref:n},u),{},{components:t})):a.createElement(d,i({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=b;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(7294),r=t(6010);const o="tabItem_Ymn6";function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>m});var a=t(7462),r=t(7294),o=t(6010),i=t(2389),s=t(7392),l=t(7094),c=t(2466);const u="tabList__CuJ",p="tabItem_LNqP";function b(e){var n;const{lazy:t,block:i,defaultValue:b,values:m,groupId:d,className:h}=e,k=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=m??k.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),g=(0,s.l)(f,((e,n)=>e.value===n.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===b?b:b??(null==(n=k.find((e=>e.props.default)))?void 0:n.props.value)??k[0].props.value;if(null!==y&&!f.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:x}=(0,l.U)(),[N,v]=(0,r.useState)(y),T=[],{blockElementScrollPositionUntilNextRender:_}=(0,c.o5)();if(null!=d){const e=w[d];null!=e&&e!==N&&f.some((n=>n.value===e))&&v(e)}const E=e=>{const n=e.currentTarget,t=T.indexOf(n),a=f[t].value;a!==N&&(_(n),v(a),null!=d&&x(d,String(a)))},C=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=T.indexOf(e.currentTarget)+1;t=T[n]??T[0];break}case"ArrowLeft":{const n=T.indexOf(e.currentTarget)-1;t=T[n]??T[T.length-1];break}}null==(n=t)||n.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},h)},f.map((e=>{let{value:n,label:t,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===n?0:-1,"aria-selected":N===n,key:n,ref:e=>T.push(e),onKeyDown:C,onFocus:E,onClick:E},i,{className:(0,o.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":N===n})}),t??n)}))),t?(0,r.cloneElement)(k.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},k.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==N})))))}function m(e){const n=(0,i.Z)();return r.createElement(b,(0,a.Z)({key:String(n)},e))}},27:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var a=t(7462),r=(t(7294),t(3905)),o=t(5488),i=t(5162);const s={sidebar_position:1,title:"Streams Subscription"},l=void 0,c={unversionedId:"usage/streams_sub",id:"usage/streams_sub",title:"Streams Subscription",description:"Transactions - subscribeNewTxs",source:"@site/docs/usage/streams_sub.mdx",sourceDirName:"usage",slug:"/usage/streams_sub",permalink:"/docs/usage/streams_sub",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usage/streams_sub.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Streams Subscription"},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/usage/getting-started"},next:{title:"Transactions Broadcasting",permalink:"/docs/usage/transaction_broad"}},u={},p=[{value:"Transactions - <code>subscribeNewTxs</code>",id:"transactions---subscribenewtxs",level:2},{value:"Filtering",id:"filtering",level:3},{value:"Block Headers - <code>subscribeNewExecutionHeaders</code>",id:"block-headers---subscribenewexecutionheaders",level:2},{value:"Block Payloads - <code>subscribeNewExecutionPayloads</code>",id:"block-payloads---subscribenewexecutionpayloads",level:2},{value:"Beacon Blocks - <code>subscribeNewBeaconBlocks</code>",id:"beacon-blocks---subscribenewbeaconblocks",level:2}],b={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},b,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"transactions---subscribenewtxs"},"Transactions - ",(0,r.kt)("inlineCode",{parentName:"h2"},"subscribeNewTxs")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This method opens a subscription in the form of a gRPC stream\nand broadcasts pending transaction that the node receives, either from the Fibernet or from full nodes\nit's connected to.")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The transactions on this stream ",(0,r.kt)("strong",{parentName:"p"},"have not been validated"),", and in some cases they can be invalid,\nso we recommend having a process for filtering out invalid transactions."),(0,r.kt)("p",{parentName:"admonition"},"The reason Fiber does this is to not introduce any latency in the message path, ensuring fastest possible delivery.")),(0,r.kt)("p",null,"Let's look at how users can subscribe to the ",(0,r.kt)("strong",{parentName:"p"},"pending transactions")," stream:"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"We're omitting the connection code snipped,\nbut your client needs to be connected to Fiber first.")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"go",label:"Golang",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "log"\n    "time"\n\n    fiber "github.com/chainbound/fiber-go"\n)\n\nfunc main() {\n    ...\n\n    // First make a sink channel on which to receive the transactions\n    ch := make(chan *fiber.Transaction)\n    go func() {\n        // This is a blocking call, so it needs to run in a Goroutine\n        if err := client.SubscribeNewTxs(nil, ch); err != nil {\n            log.Fatal(err)\n        }\n    }()\n\n    // Listen for incoming transactions\n    for tx := range ch {\n        handleTransaction(tx)\n    }\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The transaction type we use here (",(0,r.kt)("inlineCode",{parentName:"p"},"fiber.Transaction"),"), contains all possible fields of all the different transaction types. You can differentiate them\nwith the ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," field. There's also a helper method to convert this transaction to a ",(0,r.kt)("inlineCode",{parentName:"p"},"go-ethereum.types.Transaction")," type, which you can do with\n",(0,r.kt)("inlineCode",{parentName:"p"},"toNative()"),"."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-go"},"...\n\nfor tx := range ch {\n    nativeTx := tx.ToNative()\n    handleGethTransaction(nativeTx)\n}\n")))),(0,r.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use fiber::Client;\n\n#[tokio::main]\nasync fn main() {\n    // Client needs to be mutable\n    let mut client = Client::connect(\n        "beta.fiberapi.io:8080".to_string(),\n        "YOUR_API_KEY".to_string()\n    ).await.unwrap();\n\n    let mut sub = client.subscribe_new_txs(None).await;\n\n    // Consume the stream\n    while let Some(tx) = sub.next().await {\n        handle_transaction(tx);\n    }\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The stream yields transactions that are ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers::types::Transaction")," types from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gakonst/ethers-rs"},"ethers-rs")," crate."))),(0,r.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { Client, TxFilter, hexToBytes } from 'fiber-ts';\nimport { TypedTransaction } from '@ethereumjs/tx';\n\n...\n\nconst sub = client.subscribeNewTxs();\n\nsub.on(\"data\", (tx: TypedTransaction) => {\n    handleTx(tx);\n});\n"))),(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'try:\n  sub = client.subscribe_new_txs()\n\n  # Iterate over transaction stream\n  for tx in sub:\n    do_something(tx)\nexcept Exception as e:\n  print("error subscribing", e)\n')))),(0,r.kt)("h3",{id:"filtering"},"Filtering"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," methods allows for parameters which allow users to ",(0,r.kt)("strong",{parentName:"p"},"filter the transactions they receive."),"\nCurrently, we support filtering on the following transaction fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Sender"),(0,r.kt)("li",{parentName:"ul"},"Receiver"),(0,r.kt)("li",{parentName:"ul"},"MethodID"),(0,r.kt)("li",{parentName:"ul"},"Value (greater than)")),(0,r.kt)("p",null,"Here few examples to show how to use these filters:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"go",label:"Golang",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "log"\n    "time"\n\n    fiber "github.com/chainbound/fiber-go"\n)\n\nfunc main() {\n    ...\n\n    // Construct filter\n    // example 1: all transactions with either of these addresses as the receiver\n    f := filter.New(filter.Or(\n        filter.To("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),\n        filter.To("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D"),\n    ))\n\n    // example 2: all transactions with a value greater than 1 ETH\n    f := filter.New(filter.Value(big.NewInt(1) * big.NewInt(1e18)))\n\n    // example 3: all ERC20 transfers on the 2 tokens below\n    f := filter.New(filter.And(\n        filter.MethodID("0xa9059cbb"),\n        filter.Or(\n            filter.To("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),\n            filter.To("0xdAC17F958D2ee523a2206206994597C13D831ec7"),\n        ),\n    ))\n\n    ch := make(chan *fiber.Transaction)\n    go func() {\n        // apply filter\n        if err := client.SubscribeNewTxs(f, ch); err != nil {\n            log.Fatal(err)\n        }\n    }()\n\n    // Listen for incoming transactions\n    for tx := range ch {\n        handleTransaction(tx)\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Constructing filters with the Rust package is not very ergonomic yet. We're working on using macros to improve this process.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use fiber::Client;\n\n#[tokio::main]\nasync fn main() {\n    // Client needs to be mutable\n    let mut client = Client::connect(\n        "beta.fiberapi.io:8080".to_string(),\n        "YOUR_API_KEY".to_string()\n    ).await.unwrap();\n\n    // Construct filter\n    // example 1: simple receiver filter\n    let f = Filter::new()\n                .to("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D");\n\n    // example 2: all transactions with either of these addresses as the receiver\n    let f = Filter::new()\n                .or() // creates a new \'OR\' level\n                  .to("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")\n                  .to("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D");\n\n    // example 3: all ERC20 transfers on the 2 tokens below\n    let f = Filter::new()\n                .and()\n                  .method_id("0xa9059cbb")\n                  .or()\n                    .to("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")\n                    .to("0xdAC17F958D2ee523a2206206994597C13D831ec7");\n\n    // Encode the filter\n    let mut sub = client.subscribe_new_txs(f.encode().unwrap()).await;\n\n    // Consume the stream\n    while let Some(tx) = sub.next().await {\n        handle_transaction(tx);\n    }\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The stream yields transactions that are ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers::types::Transaction")," types from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gakonst/ethers-rs"},"ethers-rs")," crate."))),(0,r.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)("p",null,"\ud83d\udea7 WIP \ud83d\udea7")),(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("p",null,"\ud83d\udea7 WIP \ud83d\udea7"))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},'Evaluating filters will introduce anywhere from 10 to 200 microseconds, depending on the complexity of the filter.\nThere\'s currently a limit of 16 filter elements or "nodes" in the filter tree.')),(0,r.kt)("h2",{id:"block-headers---subscribenewexecutionheaders"},"Block Headers - ",(0,r.kt)("inlineCode",{parentName:"h2"},"subscribeNewExecutionHeaders")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExecutionHeaders")," are the headers of the blocks that are part of the execution layer (eth1).\nThese contain the traditional ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/beacon-chain.md#executionpayloadheader"},"block header"),".\nIn contrast with the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutionPayloads"),", headers ",(0,r.kt)("strong",{parentName:"p"},"do not contain the full list of transactions"),"."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Blocks streamed are not ",(0,r.kt)("strong",{parentName:"p"},"finalized"),", meaning that the data is not guaranteed to be part of the canonical chain.\nRecent blocks can always be ",(0,r.kt)("a",{parentName:"p",href:"https://www.paradigm.xyz/2021/07/ethereum-reorgs-after-the-merge"},"reorged"),".")),(0,r.kt)("p",null,"Let's see how to subscribe to new block headers in the different packages:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"go",label:"Golang",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    ...\n    fiber "github.com/chainbound/fiber-go"\n)\n\nfunc main() {\n    ...\n\n    ch := make(chan *fiber.Block)\n\n    go func() {\n        if err := client.SubscribeNewExecutionPayloadHeaders(ch); err != nil {\n            log.Fatal(err)\n        }\n    }()\n\n    for block := range ch {\n        handleBlock(block)\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use fiber::Client;\n\n#[tokio::main]\nasync fn main() {\n    let mut client = Client::connect(\n        "beta.fiberapi.io:8080".to_string(),\n        "API_KEY".to_string()\n    ).await.unwrap();\n\n    let mut sub = client.subscribe_new_execution_headers().await;\n\n    // Consume the stream\n    while let Some(block) = sub.next().await {\n        handle_block(tx);\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { Block } from "fiber-ts";\n\n...\n\nconst sub = client.subscribeNewExecutionHeaders();\n\nsub.on("data", (block: Block) => {\n  handleBlock(block);\n});\n'))),(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'try:\n  sub = client.subscribe_new_execution_payload_headers()\n\nfor block in sub:\ndo_something(block)\nexcept Exception as e:\nprint("error subscribing", e)\n')))),(0,r.kt)("h2",{id:"block-payloads---subscribenewexecutionpayloads"},"Block Payloads - ",(0,r.kt)("inlineCode",{parentName:"h2"},"subscribeNewExecutionPayloads")),(0,r.kt)("p",null,"Execution Payloads are the traditional Blocks broadcasted on the execution layer (eth1).\nThese contain the traditional ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/beacon-chain.md#executionpayloadheader"},"block header"),"\nand the full list of transactions."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Blocks streamed are not ",(0,r.kt)("strong",{parentName:"p"},"finalized"),", meaning that the data is not guaranteed to be part of the canonical chain.\nRecent blocks can always be ",(0,r.kt)("a",{parentName:"p",href:"https://www.paradigm.xyz/2021/07/ethereum-reorgs-after-the-merge"},"reorged"),".")),(0,r.kt)("p",null,"Let's see how to subscribe to new execution payloads in the different packages:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"go",label:"Golang",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    ...\n    fiber "github.com/chainbound/fiber-go"\n)\n\nfunc main() {\n    ...\n\n    ch := make(chan *fiber.Block)\n\n    go func() {\n        if err := client.SubscribeNewExecutionPayloads(ch); err != nil {\n            log.Fatal(err)\n        }\n    }()\n\n    for block := range ch {\n        handleBlock(block)\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use fiber::Client;\n\n#[tokio::main]\nasync fn main() {\n    let mut client = Client::connect(\n        "beta.fiberapi.io:8080".to_string(),\n        "API_KEY".to_string()\n    ).await.unwrap();\n\n    let mut sub = client.subscribe_new_execution_payloads().await;\n\n    // Consume the stream\n    while let Some(block) = sub.next().await {\n        handle_block(tx);\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { Block } from "fiber-ts";\n\n...\n\nconst sub = client.subscribeNewExecutionPayloads();\n\nsub.on("data", (block: Block) => {\n  handleBlock(block);\n});\n'))),(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'try:\n  sub = client.subscribe_new_execution_payloads()\n\nfor block in sub:\ndo_something(block)\nexcept Exception as e:\nprint("error subscribing", e)\n')))),(0,r.kt)("h2",{id:"beacon-blocks---subscribenewbeaconblocks"},"Beacon Blocks - ",(0,r.kt)("inlineCode",{parentName:"h2"},"subscribeNewBeaconBlocks")),(0,r.kt)("p",null,"Beacon Blocks are the blocks broadcasted on the beacon chain (eth2), which contain the canonical ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/beacon-chain.md#executionpayloadheader"},"consensus info"),".\nWe currently strip out the execution payload from this stream, as to keep the stream as light and fast as possible.\nIf you also need the execution payload, please use the ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribeNewExecutionPayloads")," stream."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Blocks streamed are not ",(0,r.kt)("strong",{parentName:"p"},"finalized"),", meaning that the data is not guaranteed to be part of the canonical chain.\nRecent blocks can always be ",(0,r.kt)("a",{parentName:"p",href:"https://www.paradigm.xyz/2021/07/ethereum-reorgs-after-the-merge"},"reorged"),".")),(0,r.kt)("p",null,"Let's see how to subscribe to new beacon blocks in the different packages:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"go",label:"Golang",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    ...\n    fiber "github.com/chainbound/fiber-go"\n)\n\nfunc main() {\n    ...\n\n    ch := make(chan *fiber.Block)\n\n    go func() {\n        if err := client.SubscribeNewBeaconBlocks(ch); err != nil {\n            log.Fatal(err)\n        }\n    }()\n\n    for block := range ch {\n        handleBlock(block)\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use fiber::Client;\n\n#[tokio::main]\nasync fn main() {\n    let mut client = Client::connect(\n        "beta.fiberapi.io:8080".to_string(),\n        "API_KEY".to_string()\n    ).await.unwrap();\n\n    let mut sub = client.subscribe_new_beacon_blocks().await;\n\n    // Consume the stream\n    while let Some(block) = sub.next().await {\n        handle_block(tx);\n    }\n}\n'))),(0,r.kt)(i.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { Block } from "fiber-ts";\n\n...\n\nconst sub = client.subscribeNewBeaconBlocks();\n\nsub.on("data", (block: Block) => {\n  handleBlock(block);\n});\n'))),(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'try:\n  sub = client.subscribe_new_beacon_blocks()\n\nfor block in sub:\ndo_something(block)\nexcept Exception as e:\nprint("error subscribing", e)\n')))))}m.isMDXComponent=!0}}]);