"use strict";(self.webpackChunkfiber_website=self.webpackChunkfiber_website||[]).push([[162],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:2,title:"Getting Started"},o=void 0,s={unversionedId:"getting-started",id:"getting-started",title:"Getting Started",description:"Users can connect to the API at fiberapi.io:8080, providing their API key in the process.",source:"@site/docs/getting-started.md",sourceDirName:".",slug:"/getting-started",permalink:"/docs/getting-started",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Getting Started"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/intro"},next:{title:"Tracing",permalink:"/docs/tracing"}},l={},c=[{value:"API Design",id:"api-design",level:2},{value:"<code>subscribeNewTxs</code>",id:"subscribenewtxs",level:4},{value:"<code>subscribeNewBlocks</code>",id:"subscribenewblocks",level:4},{value:"<code>sendTransaction</code>",id:"sendtransaction",level:4},{value:"<code>sendRawTransaction</code>",id:"sendrawtransaction",level:4},{value:"<code>backrunTransaction</code>",id:"backruntransaction",level:4},{value:"<code>rawBackrunTransaction</code>",id:"rawbackruntransaction",level:4}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Users can connect to the API at ",(0,r.kt)("inlineCode",{parentName:"p"},"fiberapi.io:8080"),", providing their API key in the process.\nThe domain will resolve to the closest node to the client, based on latency. To check this latency, just\n",(0,r.kt)("inlineCode",{parentName:"p"},"ping fiberapi.io")," from the same machine as your client."),(0,r.kt)("p",null,"The API uses gRPC. We offer a number of client packages to make this connection process as easy as possible:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Programming Language"),(0,r.kt)("th",{parentName:"tr",align:null},"Package"),(0,r.kt)("th",{parentName:"tr",align:null},"Documentation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"JavaScript / TypeScript"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/chainbound/fiber-ts"},"fiber-ts")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/chainbound/fiber-ts#readme"},"README"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Golang"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/chainbound/fiber-go"},"fiber-go")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/chainbound/fiber-go#readme"},"README"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Python"),(0,r.kt)("td",{parentName:"tr",align:null},"fiber-py (WIP)"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rust"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/chainbound/fiber-rs"},"fiber-rs")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/chainbound/fiber-rs#readme"},"README"))))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you want to build your own client (or help with the WIP implementations), all you need are the protobuf / gRPC files and a compiler for your language. Documentation for different gRPC language implementations can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://grpc.io/docs/languages/"},"https://grpc.io/docs/languages"),". The Fiber protobuf definitions are at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chainbound/fiber-proto"},"https://github.com/chainbound/fiber-proto"),". For examples of how to actually use it (API authentication), please refer to the already implemented packages.")),(0,r.kt)("h2",{id:"api-design"},"API Design"),(0,r.kt)("p",null,"The API currently consists of 6 methods:"),(0,r.kt)("h4",{id:"subscribenewtxs"},(0,r.kt)("inlineCode",{parentName:"h4"},"subscribeNewTxs")),(0,r.kt)("p",null,"This endpoint opens a subscription in the form of a gRPC stream. The stream will send any new transaction that the node receives, either from the Fibernet\nor from full nodes it's connected to. The transactions on this stream have not been validated, and in some cases they can be invalid, so we recommend\nhaving a process for filtering out invalid transactions. The reason Fiber does this is to not introduce any latency in the message path, ensuring fastest possible\ndelivery."),(0,r.kt)("h4",{id:"subscribenewblocks"},(0,r.kt)("inlineCode",{parentName:"h4"},"subscribeNewBlocks")),(0,r.kt)("p",null,"\ud83d\udea7 WIP \ud83d\udea7"),(0,r.kt)("h4",{id:"sendtransaction"},(0,r.kt)("inlineCode",{parentName:"h4"},"sendTransaction")),(0,r.kt)("p",null,"Endpoint for sending signed (v, r, s fields populated) to the Fiber Network. Fiber propagates these transactions to all other Fiber nodes, as well as all full nodes\nit's connected to."),(0,r.kt)("h4",{id:"sendrawtransaction"},(0,r.kt)("inlineCode",{parentName:"h4"},"sendRawTransaction")),(0,r.kt)("p",null,"Endpoint for sending a signed RLP encoded transaction. This is useful when you\u2019re using libraries like ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"web3.js")," with JavaScript, or ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers-rs")," with Rust."),(0,r.kt)("h4",{id:"backruntransaction"},(0,r.kt)("inlineCode",{parentName:"h4"},"backrunTransaction")),(0,r.kt)("p",null,"Endpoint for sending pairs of transactions to be propagated across the network, to ensure that they arrive at the block producer in the correct order. "),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This is not enforced in any reliable way, ",(0,r.kt)("strong",{parentName:"p"},"only")," at the p2p network layer.")),(0,r.kt)("h4",{id:"rawbackruntransaction"},(0,r.kt)("inlineCode",{parentName:"h4"},"rawBackrunTransaction")),(0,r.kt)("p",null,"Same as above but for RLP encoded signed transactions."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The API is not stable and can change in the future. This will be reflected in the client packages.")))}p.isMDXComponent=!0}}]);